"use strict";

var _casual = _interopRequireDefault(require("casual"));

var _model = _interopRequireWildcard(require("../model"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('Node', () => {
  it('`createGlobalId` should take two arguments and return a string', () => {
    const id = _casual.default.word;
    const type = _casual.default.word;
    expect(typeof (0, _model.createGlobalId)(id, type)).toEqual('string');
  });
  it('`createGlobalId` should be decodeable by `parseGlobalId`', () => {
    const id = _casual.default.word;
    const __type = _casual.default.word;
    const globalId = (0, _model.createGlobalId)(id, __type);
    expect((0, _model.parseGlobalId)(globalId)).toEqual({
      __type,
      id
    });
  });
  it('`parseGlobalId` should take a global id and return the type and id', () => {
    const id = _casual.default.word;
    const __type = _casual.default.word;
    const globalId = (0, _model.createGlobalId)(id, __type);
    expect((0, _model.parseGlobalId)(globalId)).toEqual({
      __type,
      id
    });
  });
  it('`parseGlobalId` should throw an error if ID is invalid', () => {
    expect(() => (0, _model.parseGlobalId)('blah-blah')).toThrow();
  });
  it('Node class should parse an encoded id to get the type to resolve', async () => {
    const id = _casual.default.word;
    const __type = 'Test';
    const globalId = (0, _model.createGlobalId)(id, __type);
    const dataSources = {
      Test: {
        getFromId(_id) {
          expect(_id).toEqual(id);
          return {};
        }

      }
    };
    const node = new _model.default();
    node.get(globalId, dataSources);
  });
  it("Node class should throw error if it can't find a matching model", async () => {
    const id = _casual.default.word;
    const __type = 'NoModel';
    const globalId = (0, _model.createGlobalId)(id, __type);
    const node = new _model.default({});
    expect(node.get(globalId)).rejects.toBeDefined();
  });
  it("Node class doesn't assign __type if model returns falsey", async () => {
    const id = _casual.default.word;
    const __type = 'Test';
    const globalId = (0, _model.createGlobalId)(id, __type);
    const dataSources = {
      Test: {
        getFromId() {
          return '';
        }

      }
    };
    const node = new _model.default(dataSources);
    const record = node.get(globalId);
    expect(record).not.toHaveProperty('__type');
  });
  it('Node class should return data from the models `getFromId` method', async () => {
    const id = _casual.default.word;
    const __type = 'Test';
    const globalId = (0, _model.createGlobalId)(id, __type);
    const data = {
      test: _casual.default.word
    };
    const dataSources = {
      Test: {
        getFromId() {
          return Promise.resolve(data);
        }

      }
    };
    const node = new _model.default();
    const result = await node.get(globalId, dataSources);
    expect(result.test).toEqual(data.test);
  });
  it('Node class should attach the __type to the resulting data', async () => {
    const id = _casual.default.word;
    const __type = 'Test';
    const globalId = (0, _model.createGlobalId)(id, __type);
    const data = {
      test: _casual.default.word
    };
    const dataSources = {
      Test: {
        getFromId() {
          return Promise.resolve(data);
        }

      }
    };
    const node = new _model.default();
    const result = await node.get(globalId, dataSources);
    expect(result.__type).toEqual(__type);
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ub2RlL19fdGVzdHNfXy9tb2RlbC5qcyJdLCJuYW1lcyI6WyJkZXNjcmliZSIsIml0IiwiaWQiLCJjYXN1YWwiLCJ3b3JkIiwidHlwZSIsImV4cGVjdCIsInRvRXF1YWwiLCJfX3R5cGUiLCJnbG9iYWxJZCIsInRvVGhyb3ciLCJkYXRhU291cmNlcyIsIlRlc3QiLCJnZXRGcm9tSWQiLCJfaWQiLCJub2RlIiwiTm9kZSIsImdldCIsInJlamVjdHMiLCJ0b0JlRGVmaW5lZCIsInJlY29yZCIsIm5vdCIsInRvSGF2ZVByb3BlcnR5IiwiZGF0YSIsInRlc3QiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlc3VsdCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFDQTs7Ozs7O0FBRUFBLFFBQVEsQ0FBQyxNQUFELEVBQVMsTUFBTTtBQUNyQkMsRUFBQUEsRUFBRSxDQUFDLGdFQUFELEVBQW1FLE1BQU07QUFDekUsVUFBTUMsRUFBRSxHQUFHQyxnQkFBT0MsSUFBbEI7QUFDQSxVQUFNQyxJQUFJLEdBQUdGLGdCQUFPQyxJQUFwQjtBQUVBRSxJQUFBQSxNQUFNLENBQUMsT0FBTywyQkFBZUosRUFBZixFQUFtQkcsSUFBbkIsQ0FBUixDQUFOLENBQXdDRSxPQUF4QyxDQUFnRCxRQUFoRDtBQUNELEdBTEMsQ0FBRjtBQU9BTixFQUFBQSxFQUFFLENBQUMsMERBQUQsRUFBNkQsTUFBTTtBQUNuRSxVQUFNQyxFQUFFLEdBQUdDLGdCQUFPQyxJQUFsQjtBQUNBLFVBQU1JLE1BQU0sR0FBR0wsZ0JBQU9DLElBQXRCO0FBQ0EsVUFBTUssUUFBUSxHQUFHLDJCQUFlUCxFQUFmLEVBQW1CTSxNQUFuQixDQUFqQjtBQUVBRixJQUFBQSxNQUFNLENBQUMsMEJBQWNHLFFBQWQsQ0FBRCxDQUFOLENBQWdDRixPQUFoQyxDQUF3QztBQUN0Q0MsTUFBQUEsTUFEc0M7QUFFdENOLE1BQUFBO0FBRnNDLEtBQXhDO0FBSUQsR0FUQyxDQUFGO0FBV0FELEVBQUFBLEVBQUUs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ZW50IjpbImltcG9ydCBjYXN1YWwgZnJvbSAnY2FzdWFsJztcbmltcG9ydCBOb2RlLCB7IGNyZWF0ZUdsb2JhbElkLCBwYXJzZUdsb2JhbElkIH0gZnJvbSAnLi4vbW9kZWwnO1xuXG5kZXNjcmliZSgnTm9kZScsICgpID0+IHtcbiAgaXQoJ2BjcmVhdGVHbG9iYWxJZGAgc2hvdWxkIHRha2UgdHdvIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGEgc3RyaW5nJywgKCkgPT4ge1xuICAgIGNvbnN0IGlkID0gY2FzdWFsLndvcmQ7XG4gICAgY29uc3QgdHlwZSA9IGNhc3VhbC53b3JkO1xuXG4gICAgZXhwZWN0KHR5cGVvZiBjcmVhdGVHbG9iYWxJZChpZCwgdHlwZSkpLnRvRXF1YWwoJ3N0cmluZycpO1xuICB9KTtcblxuICBpdCgnYGNyZWF0ZUdsb2JhbElkYCBzaG91bGQgYmUgZGVjb2RlYWJsZSBieSBgcGFyc2VHbG9iYWxJZGAnLCAoKSA9PiB7XG4gICAgY29uc3QgaWQgPSBjYXN1YWwud29yZDtcbiAgICBjb25zdCBfX3R5cGUgPSBjYXN1YWwud29yZDtcbiAgICBjb25zdCBnbG9iYWxJZCA9IGNyZWF0ZUdsb2JhbElkKGlkLCBfX3R5cGUpO1xuXG4gICAgZXhwZWN0KHBhcnNlR2xvYmFsSWQoZ2xvYmFsSWQpKS50b0VxdWFsKHtcbiAgICAgIF9fdHlwZSxcbiAgICAgIGlkLFxuICAgIH0pO1xuICB9KTtcblxuICBpdCgnYHBhcnNlR2xvYmFsSWRgIHNob3VsZCB0YWtlIGEgZ2xvYmFsIGlkIGFuZCByZXR1cm4gdGhlIHR5cGUgYW5kIGlkJywgKCkgPT4ge1xuICAgIGNvbnN0IGlkID0gY2FzdWFsLndvcmQ7XG4gICAgY29uc3QgX190eXBlID0gY2FzdWFsLndvcmQ7XG4gICAgY29uc3QgZ2xvYmFsSWQgPSBjcmVhdGVHbG9iYWxJZChpZCwgX190eXBlKTtcblxuICAgIGV4cGVjdChwYXJzZUdsb2JhbElkKGdsb2JhbElkKSkudG9FcXVhbCh7XG4gICAgICBfX3R5cGUsXG4gICAgICBpZCxcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoJ2BwYXJzZUdsb2JhbElkYCBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgSUQgaXMgaW52YWxpZCcsICgpID0+IHtcbiAgICBleHBlY3QoKCkgPT4gcGFyc2VHbG9iYWxJZCgnYmxhaC1ibGFoJykpLnRvVGhyb3coKTtcbiAgfSk7XG5cbiAgaXQoJ05vZGUgY2xhc3Mgc2hvdWxkIHBhcnNlIGFuIGVuY29kZWQgaWQgdG8gZ2V0IHRoZSB0eXBlIHRvIHJlc29sdmUnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgaWQgPSBjYXN1YWwud29yZDtcbiAgICBjb25zdCBfX3R5cGUgPSAnVGVzdCc7XG4gICAgY29uc3QgZ2xvYmFsSWQgPSBjcmVhdGVHbG9iYWxJZChpZCwgX190eXBlKTtcblxuICAgIGNvbnN0IGRhdGFTb3VyY2VzID0ge1xuICAgICAgVGVzdDoge1xuICAgICAgICBnZXRGcm9tSWQoX2lkKSB7XG4gICAgICAgICAgZXhwZWN0KF9pZCkudG9FcXVhbChpZCk7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgbm9kZS5nZXQoZ2xvYmFsSWQsIGRhdGFTb3VyY2VzKTtcbiAgfSk7XG5cbiAgaXQoXCJOb2RlIGNsYXNzIHNob3VsZCB0aHJvdyBlcnJvciBpZiBpdCBjYW4ndCBmaW5kIGEgbWF0Y2hpbmcgbW9kZWxcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGlkID0gY2FzdWFsLndvcmQ7XG4gICAgY29uc3QgX190eXBlID0gJ05vTW9kZWwnO1xuICAgIGNvbnN0IGdsb2JhbElkID0gY3JlYXRlR2xvYmFsSWQoaWQsIF9fdHlwZSk7XG5cbiAgICBjb25zdCBub2RlID0gbmV3IE5vZGUoe30pO1xuICAgIGV4cGVjdChub2RlLmdldChnbG9iYWxJZCkpLnJlamVjdHMudG9CZURlZmluZWQoKTtcbiAgfSk7XG5cbiAgaXQoXCJOb2RlIGNsYXNzIGRvZXNuJ3QgYXNzaWduIF9fdHlwZSBpZiBtb2RlbCByZXR1cm5zIGZhbHNleVwiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgaWQgPSBjYXN1YWwud29yZDtcbiAgICBjb25zdCBfX3R5cGUgPSAnVGVzdCc7XG4gICAgY29uc3QgZ2xvYmFsSWQgPSBjcmVhdGVHbG9iYWxJZChpZCwgX190eXBlKTtcblxuICAgIGNvbnN0IGRhdGFTb3VyY2VzID0ge1xuICAgICAgVGVzdDoge1xuICAgICAgICBnZXRGcm9tSWQoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKGRhdGFTb3VyY2VzKTtcbiAgICBjb25zdCByZWNvcmQgPSBub2RlLmdldChnbG9iYWxJZCk7XG4gICAgZXhwZWN0KHJlY29yZCkubm90LnRvSGF2ZVByb3BlcnR5KCdfX3R5cGUnKTtcbiAgfSk7XG5cbiAgaXQoJ05vZGUgY2xhc3Mgc2hvdWxkIHJldHVybiBkYXRhIGZyb20gdGhlIG1vZGVscyBgZ2V0RnJvbUlkYCBtZXRob2QnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgaWQgPSBjYXN1YWwud29yZDtcbiAgICBjb25zdCBfX3R5cGUgPSAnVGVzdCc7XG4gICAgY29uc3QgZ2xvYmFsSWQgPSBjcmVhdGVHbG9iYWxJZChpZCwgX190eXBlKTtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgdGVzdDogY2FzdWFsLndvcmQsXG4gICAgfTtcblxuICAgIGNvbnN0IGRhdGFTb3VyY2VzID0ge1xuICAgICAgVGVzdDoge1xuICAgICAgICBnZXRGcm9tSWQoKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5vZGUuZ2V0KGdsb2JhbElkLCBkYXRhU291cmNlcyk7XG5cbiAgICBleHBlY3QocmVzdWx0LnRlc3QpLnRvRXF1YWwoZGF0YS50ZXN0KTtcbiAgfSk7XG5cbiAgaXQoJ05vZGUgY2xhc3Mgc2hvdWxkIGF0dGFjaCB0aGUgX190eXBlIHRvIHRoZSByZXN1bHRpbmcgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBpZCA9IGNhc3VhbC53b3JkO1xuICAgIGNvbnN0IF9fdHlwZSA9ICdUZXN0JztcbiAgICBjb25zdCBnbG9iYWxJZCA9IGNyZWF0ZUdsb2JhbElkKGlkLCBfX3R5cGUpO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB0ZXN0OiBjYXN1YWwud29yZCxcbiAgICB9O1xuXG4gICAgY29uc3QgZGF0YVNvdXJjZXMgPSB7XG4gICAgICBUZXN0OiB7XG4gICAgICAgIGdldEZyb21JZCgpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbm9kZS5nZXQoZ2xvYmFsSWQsIGRhdGFTb3VyY2VzKTtcblxuICAgIGV4cGVjdChyZXN1bHQuX190eXBlKS50b0VxdWFsKF9fdHlwZSk7XG4gIH0pO1xufSk7XG4iXX0=