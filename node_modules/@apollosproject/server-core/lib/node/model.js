"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGlobalId = createGlobalId;
exports.parseGlobalId = parseGlobalId;
exports.default = void 0;

var _crypto = _interopRequireDefault(require("crypto"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const secret = process.env.SECRET || 'LZEVhlgzFZKClu1r';

function createGlobalId(id, type) {
  const cipher = _crypto.default.createCipher('aes192', secret);

  let encrypted = cipher.update(`${id}`, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  return `${type}:${encrypted}`;
}

function parseGlobalId(encodedId) {
  try {
    const decipher = _crypto.default.createDecipher('aes192', secret);

    const [__type, encryptedId] = encodedId.split(':');
    let decrypted = decipher.update(encryptedId, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    const id = decrypted.toString();
    return {
      __type,
      id
    };
  } catch (e) {
    throw new Error('Error parsing ID');
  }
}

class Node {
  // eslint-disable-next-line class-methods-use-this
  async get(encodedId, dataSources) {
    const {
      __type,
      id
    } = parseGlobalId(encodedId);

    if (!dataSources || !dataSources[__type] || !dataSources[__type].getFromId) {
      throw new Error(`No dataSource found using ${__type}`);
    }

    const data = await dataSources[__type].getFromId(id, encodedId);
    if (data) data.__type = __type;
    return data;
  }

}

exports.default = Node;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ub2RlL21vZGVsLmpzIl0sIm5hbWVzIjpbInNlY3JldCIsInByb2Nlc3MiLCJlbnYiLCJTRUNSRVQiLCJjcmVhdGVHbG9iYWxJZCIsImlkIiwidHlwZSIsImNpcGhlciIsIkNyeXB0byIsImNyZWF0ZUNpcGhlciIsImVuY3J5cHRlZCIsInVwZGF0ZSIsImZpbmFsIiwicGFyc2VHbG9iYWxJZCIsImVuY29kZWRJZCIsImRlY2lwaGVyIiwiY3JlYXRlRGVjaXBoZXIiLCJfX3R5cGUiLCJlbmNyeXB0ZWRJZCIsInNwbGl0IiwiZGVjcnlwdGVkIiwidG9TdHJpbmciLCJlIiwiRXJyb3IiLCJOb2RlIiwiZ2V0IiwiZGF0YVNvdXJjZXMiLCJnZXRGcm9tSWQiLCJkYXRhIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztBQUVBLE1BQU1BLE1BQU0sR0FBR0MsT0FBTyxDQUFDQyxHQUFSLENBQVlDLE1BQVosSUFBc0Isa0JBQXJDOztBQUVPLFNBQVNDLGNBQVQsQ0FBd0JDLEVBQXhCLEVBQTRCQyxJQUE1QixFQUFrQztBQUN2QyxRQUFNQyxNQUFNLEdBQUdDLGdCQUFPQyxZQUFQLENBQW9CLFFBQXBCLEVBQThCVCxNQUE5QixDQUFmOztBQUVBLE1BQUlVLFNBQVMsR0FBR0gsTUFBTSxDQUFDSSxNQUFQLENBQWUsR0FBRU4sRUFBRyxFQUFwQixFQUF1QixNQUF2QixFQUErQixLQUEvQixDQUFoQjtBQUNBSyxFQUFBQSxTQUFTLElBQUlILE1BQU0sQ0FBQ0ssS0FBUCxDQUFhLEtBQWIsQ0FBYjtBQUVBLFNBQVEsR0FBRU4sSUFBSyxJQUFHSSxTQUFVLEVBQTVCO0FBQ0Q7O0FBRU0sU0FBU0csYUFBVCxDQUF1QkMsU0FBdkIsRUFBa0M7QUFDdkMsTUFBSTtBQUNGLFVBQU1DLFFBQVEsR0FBR1AsZ0JBQU9RLGNBQVAsQ0FBc0IsUUFBdEIsRUFBZ0NoQixNQUFoQyxDQUFqQjs7QUFFQSxVQUFNLENBQUNpQixNQUFELEVBQVNDLFdBQVQsSUFBd0JKLFNBQVMsQ0FBQ0ssS0FBVixDQUFnQixHQUFoQixDQUE5QjtBQUNBLFFBQUlDLFNBQVMsR0FBR0wsUUFBUSxDQUFDSixNQUFULENBQWdCTyxXQUFoQixFQUE2QixLQUE3QixFQUFvQyxNQUFwQyxDQUFoQjtBQUNBRSxJQUFBQSxTQUFTLElBQUlMLFFBQVEsQ0FBQ0gsS0FBVCxDQUFlLE1BQWYsQ0FBYjtBQUVBLFVBQU1QLEVBQUUsR0FBR2UsU0FBUyxDQUFDQyxRQUFWLEVBQVg7QUFDQSxXQUFPO0FBQ0xKLE1BQUFBLE1BREs7QUFFTFosTUFBQUE7QUFGSyxLQUFQO0FBSUQsR0FaRCxDQVlFLE9BQU9pQixDQUFQLEVBQVU7QUFDVixVQUFNLElBQUlDLEtBQUosQ0FBVSxrQkFBVixDQUFOO0FBQ0Q7QUFDRjs7QUFFYyxNQUFNQyxJQUFOLENBQVc7QUFDeEI7QUFDQSxRQUFNQyxHQUFOLENBQVVYLFNBQVYsRUFBcUJZLFdBQXJCLEVBQWtDO0FBQ2hDLFVBQU07QUFBRVQsTUFBQUEsTUFBRjtBQUFVWixNQUFBQTtBQUFWLFFBQWlCUSxhQUFhLENBQUNDLFNBQUQsQ0FBcEM7O0FBQ0EsUUFDRSxDQUFDWSxXQUFELElBQ0EsQ0FBQ0EsV0FBVyxDQUFDVCxNQUFELENBRFosSUFFQSxDQUFDUyxXQUFXLENBQUNULE1BQUQsQ0FBWCxDQUFvQlUsU0FIdkIsRUFJRTtBQUNBLFlBQU0sSUFBSUosS0FBSixDQUFXLDZCQUE0Qk4sTUFBTyxFQUE5QyxDQUFOO0FBQ0Q7O0FBRUQsVUFBTVcsSUFBSSxHQUFHLE1BQU1GLFdBQVcsQ0FBQ1QsTUFBRCxDQUFYLENBQW9CVSxTQUFwQixDQUE4QnRCLEVBQTlCLEVBQWtDUyxTQUFsQyxDQUFuQjtBQUNBLFFBQUljLElBQUosRUFBVUEsSUFBSSxDQUFDWCxNQUFMLEdBQWNBLE1BQWQ7QUFDVixXQUFPVyxJQUFQO0FBQ0Q7O0FBZnVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5jb25zdCBzZWNyZXQgPSBwcm9jZXNzLmVudi5TRUNSRVQgfHwgJ0xaRVZobGd6RlpLQ2x1MXInO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlR2xvYmFsSWQoaWQsIHR5cGUpIHtcbiAgY29uc3QgY2lwaGVyID0gQ3J5cHRvLmNyZWF0ZUNpcGhlcignYWVzMTkyJywgc2VjcmV0KTtcblxuICBsZXQgZW5jcnlwdGVkID0gY2lwaGVyLnVwZGF0ZShgJHtpZH1gLCAndXRmOCcsICdoZXgnKTtcbiAgZW5jcnlwdGVkICs9IGNpcGhlci5maW5hbCgnaGV4Jyk7XG5cbiAgcmV0dXJuIGAke3R5cGV9OiR7ZW5jcnlwdGVkfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUdsb2JhbElkKGVuY29kZWRJZCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY2lwaGVyID0gQ3J5cHRvLmNyZWF0ZURlY2lwaGVyKCdhZXMxOTInLCBzZWNyZXQpO1xuXG4gICAgY29uc3QgW19fdHlwZSwgZW5jcnlwdGVkSWRdID0gZW5jb2RlZElkLnNwbGl0KCc6Jyk7XG4gICAgbGV0IGRlY3J5cHRlZCA9IGRlY2lwaGVyLnVwZGF0ZShlbmNyeXB0ZWRJZCwgJ2hleCcsICd1dGY4Jyk7XG4gICAgZGVjcnlwdGVkICs9IGRlY2lwaGVyLmZpbmFsKCd1dGY4Jyk7XG5cbiAgICBjb25zdCBpZCA9IGRlY3J5cHRlZC50b1N0cmluZygpO1xuICAgIHJldHVybiB7XG4gICAgICBfX3R5cGUsXG4gICAgICBpZCxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBwYXJzaW5nIElEJyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGFzeW5jIGdldChlbmNvZGVkSWQsIGRhdGFTb3VyY2VzKSB7XG4gICAgY29uc3QgeyBfX3R5cGUsIGlkIH0gPSBwYXJzZUdsb2JhbElkKGVuY29kZWRJZCk7XG4gICAgaWYgKFxuICAgICAgIWRhdGFTb3VyY2VzIHx8XG4gICAgICAhZGF0YVNvdXJjZXNbX190eXBlXSB8fFxuICAgICAgIWRhdGFTb3VyY2VzW19fdHlwZV0uZ2V0RnJvbUlkXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRhdGFTb3VyY2UgZm91bmQgdXNpbmcgJHtfX3R5cGV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGRhdGFTb3VyY2VzW19fdHlwZV0uZ2V0RnJvbUlkKGlkLCBlbmNvZGVkSWQpO1xuICAgIGlmIChkYXRhKSBkYXRhLl9fdHlwZSA9IF9fdHlwZTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuIl19