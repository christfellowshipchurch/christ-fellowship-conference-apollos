"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _apolloServer = require("apollo-server");

var _apolloServerEnv = require("apollo-server-env");

var _moment = _interopRequireDefault(require("moment"));

var _rockApolloDataSource = _interopRequireDefault(require("@apollosproject/rock-apollo-data-source"));

var _token = require("./token");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class AuthDataSource extends _rockApolloDataSource.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "resource", 'Auth');

    _defineProperty(this, "rockCookie", null);

    _defineProperty(this, "userToken", null);

    _defineProperty(this, "getCurrentPerson", async ({
      cookie
    } = {
      cookie: null
    }) => {
      const {
        rockCookie
      } = this.context;
      const userCookie = cookie || rockCookie;

      if (userCookie) {
        const request = await this.request('People/GetCurrentPerson').get({
          options: {
            headers: {
              cookie: userCookie
            }
          }
        });
        return request;
      }

      throw new _apolloServer.AuthenticationError('Must be logged in');
    });

    _defineProperty(this, "fetchUserCookie", async (Username, Password) => {
      try {
        // We use `new Response` rather than string/options b/c if conforms more closely with ApolloRESTDataSource
        // (makes mocking in tests WAY easier to use `new Request` as an input in both places)
        const response = await (0, _apolloServerEnv.fetch)(new _apolloServerEnv.Request(`${this.baseURL}/Auth/Login`, {
          method: 'POST',
          body: JSON.stringify({
            Username,
            Password
          }),
          headers: {
            'Content-Type': 'Application/Json'
          }
        }));
        if (response.status >= 400) throw new _apolloServer.AuthenticationError();
        const cookie = response.headers.get('set-cookie');
        return cookie;
      } catch (err) {
        throw new _apolloServer.AuthenticationError('Invalid Credentials');
      }
    });

    _defineProperty(this, "createSession", async ({
      cookie
    }) => {
      const currentUser = await this.getCurrentPerson({
        cookie
      });
      return this.post('/InteractionSessions', {
        PersonAliasId: currentUser.primaryAliasId
      });
    });

    _defineProperty(this, "authenticate", async ({
      identity,
      password
    }) => {
      try {
        const cookie = await this.fetchUserCookie(identity, password);
        const sessionId = await this.createSession({
          cookie
        });
        const token = (0, _token.generateToken)({
          cookie,
          sessionId
        });
        const {
          userToken,
          rockCookie
        } = (0, _token.registerToken)(token);
        this.context.rockCookie = rockCookie;
        this.context.userToken = userToken;
        this.context.sessionId = sessionId;
        return {
          token,
          rockCookie
        };
      } catch (e) {
        throw e;
      }
    });

    _defineProperty(this, "personExists", async ({
      identity
    }) => {
      const hasUserName = await this.request(`/UserLogins?$filter=UserName eq '${identity}'`).get();

      if (hasUserName.length) {
        return true;
      }

      return false;
    });

    _defineProperty(this, "createUserProfile", async (props = {}) => {
      try {
        const {
          email
        } = props;
        return await this.post('/People', {
          Email: email,
          IsSystem: false,
          // Required by Rock
          Gender: 0 // Required by Rock

        });
      } catch (err) {
        throw new Error('Unable to create profile!');
      }
    });

    _defineProperty(this, "createUserLogin", async (props = {}) => {
      try {
        const {
          email,
          password,
          personId
        } = props;
        return await this.post('/UserLogins', {
          PersonId: personId,
          EntityTypeId: 27,
          // A default setting we use in Rock-person-creation-flow
          UserName: email,
          PlainTextPassword: password,
          LastLoginDateTime: `${(0, _moment.default)().toISOString()}`
        });
      } catch (err) {
        throw new Error('Unable to create user login!');
      }
    });

    _defineProperty(this, "changePassword", async ({
      password
    }) => {
      const currentUser = await this.getCurrentPerson();
      const {
        email,
        id
      } = currentUser;
      const logins = await this.request('/UserLogins').filter(`UserName eq '${email}'`).get();

      if (logins.length > 0) {
        await this.delete(`/UserLogins/${logins[0].id}`);
      }

      await this.createUserLogin({
        personId: id,
        email,
        password
      });
      return this.authenticate({
        identity: email,
        password
      });
    });

    _defineProperty(this, "registerPerson", async ({
      email,
      password
    }) => {
      const personExists = await this.personExists({
        identity: email
      });
      if (personExists) throw new Error('User already exists!');
      const personId = await this.createUserProfile({
        email
      });
      await this.createUserLogin({
        email,
        password,
        personId
      });
      const token = await this.authenticate({
        identity: email,
        password
      });
      return token;
    });
  }

}

exports.default = AuthDataSource;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9kYXRhLXNvdXJjZS5qcyJdLCJuYW1lcyI6WyJBdXRoRGF0YVNvdXJjZSIsIlJvY2tBcG9sbG9EYXRhU291cmNlIiwiY29va2llIiwicm9ja0Nvb2tpZSIsImNvbnRleHQiLCJ1c2VyQ29va2llIiwicmVxdWVzdCIsImdldCIsIm9wdGlvbnMiLCJoZWFkZXJzIiwiQXV0aGVudGljYXRpb25FcnJvciIsIlVzZXJuYW1lIiwiUGFzc3dvcmQiLCJyZXNwb25zZSIsIlJlcXVlc3QiLCJiYXNlVVJMIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGF0dXMiLCJlcnIiLCJjdXJyZW50VXNlciIsImdldEN1cnJlbnRQZXJzb24iLCJwb3N0IiwiUGVyc29uQWxpYXNJZCIsInByaW1hcnlBbGlhc0lkIiwiaWRlbnRpdHkiLCJwYXNzd29yZCIsImZldGNoVXNlckNvb2tpZSIsInNlc3Npb25JZCIsImNyZWF0ZVNlc3Npb24iLCJ0b2tlbiIsInVzZXJUb2tlbiIsImUiLCJoYXNVc2VyTmFtZSIsImxlbmd0aCIsInByb3BzIiwiZW1haWwiLCJFbWFpbCIsIklzU3lzdGVtIiwiR2VuZGVyIiwiRXJyb3IiLCJwZXJzb25JZCIsIlBlcnNvbklkIiwiRW50aXR5VHlwZUlkIiwiVXNlck5hbWUiLCJQbGFpblRleHRQYXNzd29yZCIsIkxhc3RMb2dpbkRhdGVUaW1lIiwidG9JU09TdHJpbmciLCJpZCIsImxvZ2lucyIsImZpbHRlciIsImRlbGV0ZSIsImNyZWF0ZVVzZXJMb2dpbiIsImF1dGhlbnRpY2F0ZSIsInBlcnNvbkV4aXN0cyIsImNyZWF0ZVVzZXJQcm9maWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7OztBQUVlLE1BQU1BLGNBQU4sU0FBNkJDLDZCQUE3QixDQUFrRDtBQUFBO0FBQUE7O0FBQUEsc0NBQ3BELE1BRG9EOztBQUFBLHdDQUdsRCxJQUhrRDs7QUFBQSx1Q0FLbkQsSUFM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QUFJZCxLQUFKLENBQVUsc0JBQVYsQ0FBTjtBQUVsQixZQUFNQyxRQUFRLEdBQUcsTUFBTSxLQUFLYyxpQkFBTCxDQUF1QjtBQUFFbkIsUUFBQUE7QUFBRixPQUF2QixDQUF2QjtBQUNBLFlBQU0sS0FBS2dCLGVBQUwsQ0FBcUI7QUFDekJoQixRQUFBQSxLQUR5QjtBQUV6QlYsUUFBQUEsUUFGeUI7QUFHekJlLFFBQUFBO0FBSHlCLE9BQXJCLENBQU47QUFNQSxZQUFNWCxLQUFLLEdBQUcsTUFBTSxLQUFLdUIsWUFBTCxDQUFrQjtBQUFFNUIsUUFBQUEsUUFBUSxFQUFFVyxLQUFaO0FBQW1CVixRQUFBQTtBQUFuQixPQUFsQixDQUFwQjtBQUNBLGFBQU9JLEtBQVA7QUFDRCxLQTVJOEQ7QUFBQTs7QUFBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF1dGhlbnRpY2F0aW9uRXJyb3IgfSBmcm9tICdhcG9sbG8tc2VydmVyJztcbmltcG9ydCB7IGZldGNoLCBSZXF1ZXN0IH0gZnJvbSAnYXBvbGxvLXNlcnZlci1lbnYnO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IFJvY2tBcG9sbG9EYXRhU291cmNlIGZyb20gJ0BhcG9sbG9zcHJvamVjdC9yb2NrLWFwb2xsby1kYXRhLXNvdXJjZSc7XG5cbmltcG9ydCB7IGdlbmVyYXRlVG9rZW4sIHJlZ2lzdGVyVG9rZW4gfSBmcm9tICcuL3Rva2VuJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0aERhdGFTb3VyY2UgZXh0ZW5kcyBSb2NrQXBvbGxvRGF0YVNvdXJjZSB7XG4gIHJlc291cmNlID0gJ0F1dGgnO1xuXG4gIHJvY2tDb29raWUgPSBudWxsO1xuXG4gIHVzZXJUb2tlbiA9IG51bGw7XG5cbiAgZ2V0Q3VycmVudFBlcnNvbiA9IGFzeW5jICh7IGNvb2tpZSB9ID0geyBjb29raWU6IG51bGwgfSkgPT4ge1xuICAgIGNvbnN0IHsgcm9ja0Nvb2tpZSB9ID0gdGhpcy5jb250ZXh0O1xuICAgIGNvbnN0IHVzZXJDb29raWUgPSBjb29raWUgfHwgcm9ja0Nvb2tpZTtcbiAgICBpZiAodXNlckNvb2tpZSkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IGF3YWl0IHRoaXMucmVxdWVzdCgnUGVvcGxlL0dldEN1cnJlbnRQZXJzb24nKS5nZXQoe1xuICAgICAgICBvcHRpb25zOiB7IGhlYWRlcnM6IHsgY29va2llOiB1c2VyQ29va2llIH0gfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKCdNdXN0IGJlIGxvZ2dlZCBpbicpO1xuICB9O1xuXG4gIGZldGNoVXNlckNvb2tpZSA9IGFzeW5jIChVc2VybmFtZSwgUGFzc3dvcmQpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gV2UgdXNlIGBuZXcgUmVzcG9uc2VgIHJhdGhlciB0aGFuIHN0cmluZy9vcHRpb25zIGIvYyBpZiBjb25mb3JtcyBtb3JlIGNsb3NlbHkgd2l0aCBBcG9sbG9SRVNURGF0YVNvdXJjZVxuICAgICAgLy8gKG1ha2VzIG1vY2tpbmcgaW4gdGVzdHMgV0FZIGVhc2llciB0byB1c2UgYG5ldyBSZXF1ZXN0YCBhcyBhbiBpbnB1dCBpbiBib3RoIHBsYWNlcylcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgIG5ldyBSZXF1ZXN0KGAke3RoaXMuYmFzZVVSTH0vQXV0aC9Mb2dpbmAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBVc2VybmFtZSxcbiAgICAgICAgICAgIFBhc3N3b3JkLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnQXBwbGljYXRpb24vSnNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoKTtcbiAgICAgIGNvbnN0IGNvb2tpZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdzZXQtY29va2llJyk7XG4gICAgICByZXR1cm4gY29va2llO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoJ0ludmFsaWQgQ3JlZGVudGlhbHMnKTtcbiAgICB9XG4gIH07XG5cbiAgY3JlYXRlU2Vzc2lvbiA9IGFzeW5jICh7IGNvb2tpZSB9KSA9PiB7XG4gICAgY29uc3QgY3VycmVudFVzZXIgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRQZXJzb24oeyBjb29raWUgfSk7XG4gICAgcmV0dXJuIHRoaXMucG9zdCgnL0ludGVyYWN0aW9uU2Vzc2lvbnMnLCB7XG4gICAgICBQZXJzb25BbGlhc0lkOiBjdXJyZW50VXNlci5wcmltYXJ5QWxpYXNJZCxcbiAgICB9KTtcbiAgfTtcblxuICBhdXRoZW50aWNhdGUgPSBhc3luYyAoeyBpZGVudGl0eSwgcGFzc3dvcmQgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb29raWUgPSBhd2FpdCB0aGlzLmZldGNoVXNlckNvb2tpZShpZGVudGl0eSwgcGFzc3dvcmQpO1xuICAgICAgY29uc3Qgc2Vzc2lvbklkID0gYXdhaXQgdGhpcy5jcmVhdGVTZXNzaW9uKHsgY29va2llIH0pO1xuICAgICAgY29uc3QgdG9rZW4gPSBnZW5lcmF0ZVRva2VuKHsgY29va2llLCBzZXNzaW9uSWQgfSk7XG4gICAgICBjb25zdCB7IHVzZXJUb2tlbiwgcm9ja0Nvb2tpZSB9ID0gcmVnaXN0ZXJUb2tlbih0b2tlbik7XG4gICAgICB0aGlzLmNvbnRleHQucm9ja0Nvb2tpZSA9IHJvY2tDb29raWU7XG4gICAgICB0aGlzLmNvbnRleHQudXNlclRva2VuID0gdXNlclRva2VuO1xuICAgICAgdGhpcy5jb250ZXh0LnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgIHJldHVybiB7IHRva2VuLCByb2NrQ29va2llIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG5cbiAgcGVyc29uRXhpc3RzID0gYXN5bmMgKHsgaWRlbnRpdHkgfSkgPT4ge1xuICAgIGNvbnN0IGhhc1VzZXJOYW1lID0gYXdhaXQgdGhpcy5yZXF1ZXN0KFxuICAgICAgYC9Vc2VyTG9naW5zPyRmaWx0ZXI9VXNlck5hbWUgZXEgJyR7aWRlbnRpdHl9J2BcbiAgICApLmdldCgpO1xuXG4gICAgaWYgKGhhc1VzZXJOYW1lLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBjcmVhdGVVc2VyUHJvZmlsZSA9IGFzeW5jIChwcm9wcyA9IHt9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZW1haWwgfSA9IHByb3BzO1xuXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0KCcvUGVvcGxlJywge1xuICAgICAgICBFbWFpbDogZW1haWwsXG4gICAgICAgIElzU3lzdGVtOiBmYWxzZSwgLy8gUmVxdWlyZWQgYnkgUm9ja1xuICAgICAgICBHZW5kZXI6IDAsIC8vIFJlcXVpcmVkIGJ5IFJvY2tcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY3JlYXRlIHByb2ZpbGUhJyk7XG4gICAgfVxuICB9O1xuXG4gIGNyZWF0ZVVzZXJMb2dpbiA9IGFzeW5jIChwcm9wcyA9IHt9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBwZXJzb25JZCB9ID0gcHJvcHM7XG5cbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3QoJy9Vc2VyTG9naW5zJywge1xuICAgICAgICBQZXJzb25JZDogcGVyc29uSWQsXG4gICAgICAgIEVudGl0eVR5cGVJZDogMjcsIC8vIEEgZGVmYXVsdCBzZXR0aW5nIHdlIHVzZSBpbiBSb2NrLXBlcnNvbi1jcmVhdGlvbi1mbG93XG4gICAgICAgIFVzZXJOYW1lOiBlbWFpbCxcbiAgICAgICAgUGxhaW5UZXh0UGFzc3dvcmQ6IHBhc3N3b3JkLFxuICAgICAgICBMYXN0TG9naW5EYXRlVGltZTogYCR7bW9tZW50KCkudG9JU09TdHJpbmcoKX1gLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjcmVhdGUgdXNlciBsb2dpbiEnKTtcbiAgICB9XG4gIH07XG5cbiAgY2hhbmdlUGFzc3dvcmQgPSBhc3luYyAoeyBwYXNzd29yZCB9KSA9PiB7XG4gICAgY29uc3QgY3VycmVudFVzZXIgPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRQZXJzb24oKTtcbiAgICBjb25zdCB7IGVtYWlsLCBpZCB9ID0gY3VycmVudFVzZXI7XG4gICAgY29uc3QgbG9naW5zID0gYXdhaXQgdGhpcy5yZXF1ZXN0KCcvVXNlckxvZ2lucycpXG4gICAgICAuZmlsdGVyKGBVc2VyTmFtZSBlcSAnJHtlbWFpbH0nYClcbiAgICAgIC5nZXQoKTtcblxuICAgIGlmIChsb2dpbnMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGUoYC9Vc2VyTG9naW5zLyR7bG9naW5zWzBdLmlkfWApO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmNyZWF0ZVVzZXJMb2dpbih7XG4gICAgICBwZXJzb25JZDogaWQsXG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmF1dGhlbnRpY2F0ZSh7XG4gICAgICBpZGVudGl0eTogZW1haWwsXG4gICAgICBwYXNzd29yZCxcbiAgICB9KTtcbiAgfTtcblxuICByZWdpc3RlclBlcnNvbiA9IGFzeW5jICh7IGVtYWlsLCBwYXNzd29yZCB9KSA9PiB7XG4gICAgY29uc3QgcGVyc29uRXhpc3RzID0gYXdhaXQgdGhpcy5wZXJzb25FeGlzdHMoeyBpZGVudGl0eTogZW1haWwgfSk7XG4gICAgaWYgKHBlcnNvbkV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdVc2VyIGFscmVhZHkgZXhpc3RzIScpO1xuXG4gICAgY29uc3QgcGVyc29uSWQgPSBhd2FpdCB0aGlzLmNyZWF0ZVVzZXJQcm9maWxlKHsgZW1haWwgfSk7XG4gICAgYXdhaXQgdGhpcy5jcmVhdGVVc2VyTG9naW4oe1xuICAgICAgZW1haWwsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHBlcnNvbklkLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmF1dGhlbnRpY2F0ZSh7IGlkZW50aXR5OiBlbWFpbCwgcGFzc3dvcmQgfSk7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9O1xufVxuIl19